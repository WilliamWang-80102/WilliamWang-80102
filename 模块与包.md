# Python导入机制

## Module

一个.py文件就是一个模块

## Package

模块包是包含了__init.py__文件的目录，用于避免模块名称冲突。

## Python模块搜索路径

1. 程序的根目录
2. PYTHONPATH环境变量设置的目录
3. 标准库的目录
4. 任何能够找到的.pth文件的内容
5. 第三方扩展的site-package目录

最终，这五个部分的拼接成为了sys.path，其中第一和第三、第五部分是自动定义的。

### 根目录(自动)

Python首先在根目录搜索要导入的文件。这个根目录的入口依赖于你怎么运行代码；当你运行一个程序时，这个入口就是程序运行入口(top-level script file)文件所在的目录；当你用交互式窗口期运行代码时，这个入口就是你所在的工作目录。

### PYTHONPATH 目录(可配置的)

接下来，python会搜索PYTHONPATH环境变量里列出的所有目录，因为这个搜索在标准库之前，所以要小心不要覆盖一些标准库的同名模块。

### 标准库目录(自动)

这个没什么好说的，pyton会自动搜寻标准库模块所在的目录。

### .pth文件列出的目录(可配置的)

这是用的比较少的一个python特性。它允许用户以每行一个的方式列出搜索路径，它和PYTHONPATH环境变量的不同是会在标准库路径之后搜索；而且它是针对这个python安装的，而不是针对用户的（环境变量会随着用户的不同而不同）。 那么，.pth文件应该放在哪里呢？

### Lib/site-package目录(自动)

最后，python会在搜索路径上自动加上site-packages目录，这一般是第三方扩展安装的地方，一般是由distutils工具发布的。

## 绝对导入与相对导入

绝对导入的格式为 import A.B 或 from A import B，相对导入格式为 from . import B 或 from ..A import B，.代表当前模块，..代表上层模块，...代表上上层模块，依次类推。

相对导入可以避免硬编码带来的维护问题，例如我们改了某一顶层包的名，那么其子包所有的导入就都不能用了。但是存在相对导入语句的模块，不能直接运行，否则会有异常：

```python
ValueError: Attempted relative import in non-package
```

### 相对导入

`from . import module`
注：当执行脚本为顶层脚本（top level script）时，python解释器会报错。

`from ..UpperPackage import Module`, `from ...UpperUpperPackage import Module`  
一个.表示当前，两个.表示上层包，三个表示上上层包。

### 绝对导入

`import module`
python3默认行为。优先搜索当前目录以外的模块。
python2.5以上版本可以通过`from __future__ import module`执行绝对导入。

## 导入过程 

### import module_name

1. 在import的过程中发生了哪些事情：
import一个模块相当于先执行了一次这个被导入模块，然后在本命名空间建立一个与被导入模块命名空间的联系，
相当于在本命名空间新建了一个变量，这个变量名称是被导入模块的名称，指向被导入模块的命名空间。

2. 一个模块不会被重复导入
也就是说，import了一次这个模块，然后再import一次，也只是执行了第一次的import

    ```python
    import My_module  # 执行了
    import My_module  # 不会执行
    ```

3. 如何去使用被导入模块中的名字

    ```python
    import My_module
    print(My_module.name)               # 打印出My_module中的name
    My_module.My_module_fun()   # 执行了My_module中的函数
    ```

4. 本文件中存在一个变量，这个变量名是导入的模块名
这个时候就相当于把指向导入模块的指针断开了，再指向新的值

    ```python
    My_module = 1
    print(My_module)  # 1
    My_module.read()  #报错
    ```

5. 一次导入多个模块的方式
`import os,time,My_module`但是一般不建议这么使用，因为根据pep8规范(python编写规范)：
我们导入模块的顺序应该是：内置模块，第三方模块，自定义模块

    ```python
    import os          # 内置
    import time      # 内置

    import django  # 第三方

    import my_module  # 自定义
    ```

6. 给模块起别名，一旦给模块起了别名，那么原名就不能使用了

    ```python
    import My_module as m
    print(m.name)  # 帅锅
    print(My_module.name)  # 报错
    ```

7. 交叉导入
错误

### from import

1. 在from import的过程中发生了哪些事情

    ```python
    from My_module import name
    from My_module import read
    ```

    - 要找到My_module
    - 开空间，执行my_module
    - 所有的My_module中的名字都存储在My_module所属的空间中
    - 本文件空间中建立对应的变量名(name，read)，分别取引用My_module空间中对应的名字

2. 引用模块的变量后，进行修改(看图)

    ```python
    from My_module import name
    from My_module import read
    print(name)   # 帅锅

    name = 'aaa'
    read()            # in read 帅锅

    print(name)  # aaa
    ```

3. from import 多个内容

    ```python
    from My_module import name,read,read2
    ```

4. 给导入的内容起别名

    ```python
    from My_module import name as n,read as r,read2 as r2`
    ```

5. from import *和 __all__关系
只有from import * 没有__all__的时候，My_module的所有变量都可以在本文件中使用。

    ```python
    from My_module import *
    print(name)   # 帅锅
    read()            # in read 帅锅
    read2()         # in read2 帅锅
    ```

    既有from import *  也有__all__的时候，只有被__all__声明的变量才能在本文件中使用。
    My_module中：`__all__ = ['name','read']`
    本文件中执行：

    ```python
    from My_module import *
    print(name)     # 帅锅
    read()              # in read 帅锅
    read2()            # 报错：name 'read2' is not defined
    ```

### 包导入

1. 规则
    1. 无论是import形式还是from...import形式，凡是在导入语句中遇到带点的都是关于包的导入语法。

    2. 包的本质就是一个包含__init__.py文件的目录

    3. import导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的__init__.py，导入包本质就是在导入该文件

    4. 导入包就相当于执行力这个包下的__init__.py文件，在__init__下导入了什么模块，你就等于导入了什么模块

    5. 强调：
        1. 在python3中，即使包下没有__init__.py文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import 包会报错
        2. 创建包的目的不是为了运行，而是被导入使用，记住，包只是模块的一种形式而已，包即模块

2. import什么，调用的时候就要写全

    ```python
    import glance.db.models
    glance.db.models.register_models('hello')  # from models.py:  hello
    ```

3. from...import
需要注意的是from后import导入的模块，必须是明确的一个不能带点，否则会有语法错误，如：`from a import b.c`是错误语法

    ```python
    from glance.db import models
    models.register_models('hello')
    ```

4. \_\_init\_\_.py文件
    不管是哪种方式，只要是第一次导入包或者是包的任何其他部分，都会依次执行包下的 \_\_init\_\_.py文件，也就是说每次导入一个包都会先执行包下的 \_\_init\_\_.py文件。在包api下的 \_\_init\_\_.py文件写入这样的代码：

    ```python
    print('__init__')
    __all__ = ['policy']
    ```

    然后在主程序执行：

    ```python
    from glance.api import *
    policy.get()  # __init__   # from policy.py
    versions.create_resource('aa')  # 报错：name 'versions' is not defined
    ```

5. 单独导入包
直接单独导入包，比如`import glance`,是不会导入包中的模块的，直接导入包名称的时候，只会去执行包中的\_\_init\_\_文件，所以单独导入包名称的时候，需要去包下的\_\_init\_\_文件中导入相应的模块。

## 参考

1. <https://www.cnblogs.com/Zzbj/p/9607462.html>
2. <https://www.jianshu.com/p/5cc20b88bcf4>
3. <https://blog.csdn.net/fitzzhang/article/details/78988155>
